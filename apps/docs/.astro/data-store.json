[["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.13.0","content-config-digest","4e715b3916c01e4c","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"math\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"staticImportMetaEnv\":false,\"chromeDevtoolsWorkspace\":false},\"legacy\":{\"collections\":false}}","docs",["Map",11,12,33,34,78,79,116,117],"history",{"id":11,"data":13,"body":14,"filePath":15,"digest":16,"rendered":17},{},"# Historic context of web development\n\nMulti-Page Apps (MPAs) were the earliest architecture used on the web, relying on server-side rendering. As the web evolved, the need for more interactivity and improved user experience led to the transition over Progressively Enhanced Multi-Page Apps (PEMPAs, aka \"JavaScript Sprinkles\"), which relied on server-side rendering and client-side fetching of HTML (Ajax) to Single Page Apps (SPAs), which separated the UI code from the backend. SPAs only fetch data and render the HTML on the client side. However, SPAs have their own trade-offs, such as slower initial load times and SEO challenges. The next transition in web development architecture is currently underway, aiming to address the limitations of SPAs and MPAs.\n\n_(Source: [Kent C. Dodds - The Web’s Next Transition](https://www.epicweb.dev/the-webs-next-transition))_\n\n## Present\n\nMultiple solutions are in place that promise a compromise between SPAs and MPAs. On a high level a lot of them follow a similar strategy (e.g. SSR + Hydration) and aim to give the developer more control over which parts need to be interactive (and involve the usage of JavaScript) and which don't. Some of these solutions try to leverage the web platform and standards as much as possible, while others chose more custom and proprietary ways.","../../docs/history.md","4bf8379675d65281",{"html":18,"metadata":19},"\u003Ch1 id=\"historic-context-of-web-development\">Historic context of web development\u003C/h1>\n\u003Cp>Multi-Page Apps (MPAs) were the earliest architecture used on the web, relying on server-side rendering. As the web evolved, the need for more interactivity and improved user experience led to the transition over Progressively Enhanced Multi-Page Apps (PEMPAs, aka “JavaScript Sprinkles”), which relied on server-side rendering and client-side fetching of HTML (Ajax) to Single Page Apps (SPAs), which separated the UI code from the backend. SPAs only fetch data and render the HTML on the client side. However, SPAs have their own trade-offs, such as slower initial load times and SEO challenges. The next transition in web development architecture is currently underway, aiming to address the limitations of SPAs and MPAs.\u003C/p>\n\u003Cp>\u003Cem>(Source: \u003Ca href=\"https://www.epicweb.dev/the-webs-next-transition\">Kent C. Dodds - The Web’s Next Transition\u003C/a>)\u003C/em>\u003C/p>\n\u003Ch2 id=\"present\">Present\u003C/h2>\n\u003Cp>Multiple solutions are in place that promise a compromise between SPAs and MPAs. On a high level a lot of them follow a similar strategy (e.g. SSR + Hydration) and aim to give the developer more control over which parts need to be interactive (and involve the usage of JavaScript) and which don’t. Some of these solutions try to leverage the web platform and standards as much as possible, while others chose more custom and proprietary ways.\u003C/p>",{"headings":20,"localImagePaths":29,"remoteImagePaths":30,"frontmatter":31,"imagePaths":32},[21,25],{"depth":22,"slug":23,"text":24},1,"historic-context-of-web-development","Historic context of web development",{"depth":26,"slug":27,"text":28},2,"present","Present",[],[],{},[],"goals",{"id":33,"data":35,"body":36,"filePath":37,"digest":38,"rendered":39},{},"# Main goals that strategies and technologies should achieve\n\nThe most relevant achievements that should be looked at, are the user satisfaction and the production cost.\n\nThe production cost can be split into labour cost (business, legal, marketing, ux, ui, development, qa, operations and probably many more) and other costs (hardware, software, licenses and many more). The user satisfaction is tied to the performace, correctness, availability, security, usability and a bunch of psychological influences that I don't know enough of to write about.\n\nTo evaluate strategies and tools to build frontends for web applications, this deep dive will focus on the labour cost of development and the performance and usability of the product. With the exception of security, most other costs and causes for user satisfaction are not very strongly influenced by the choice of frontend application tooling.\n\nTo make solutions comparable, we will take specific measurements, more subjective evaluations and turn them into ratings on a scale of 1 (very bad) to 10 (very good).\n\n## Development cost\n\nThe development cost is directly related to the time spent on a specific iteration of the product. So whichever solution supports the team the most in building and mainting the product, will be the most cost effective one. The time will be influenced by...\n\n- **Setup Time**: Measure the time taken to set up a new project with each framework\n- **Developer Productivity**: Evaluate the ease of development, availability of documentation, and community support\n- **Maintainability**: Assess how easy it is to add new features and refactor existing code\n  - **Consistency**: Evaluate adherence to coding standards and best practices\n  - **Testability**: Measure the ease of writing unit tests and integration tests for the codebase\n  - **Complexity**\n    - **Code Complexity**: Use tools like cyclomatic complexity to measure the complexity of the codebase\n    - **Architecture Complexity**: Evaluate the complexity of the chosen architecture\n    - **Dependency Management**: Assess the complexity of managing dependencies and version compatibility\n    - **Tooling Complexity**: Measure the complexity of tooling required for development, testing, and deployment\n\nWe won't look at all of these measurements in detail and might only add them to the mix once we realised that indeed there are significant differences between the solutions. The focus will be on **Developer Productivity** and **Maintainability** via **Complexity** and **Testability**.\n\n## Performance\n\nWhile improving the performance can be a cost cutting operation, we'll look at it from the perspective of user satisfaction. Which means only metrics that influence the user experience directly will be looked at.\n\n### Largest Contentful Paint (LCP)\n\nMeasures the time it takes for the largest content element (e.g., image, text block) within the viewport to become visible to the user\n\n### Cumulative Layout Shift (CLS)\n\nMeasures the cumulative sum of all individual layout shift scores that occur during the entire lifespan of the page\n\n### Interaction to Next Paint (INP)\n\n_([Limited Browser Support as of 08.2024](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEventTiming/interactionId#browser_compatibility))_ INP improves on FID by observing all interactions on a page, beginning from the input delay, to the time it takes to run event handlers, and finally up until the browser has painted the next frame.\n\n### First Input Delay (FID)\n\n_([Succeeded by INP](https://web.dev/articles/inp#inp-vs-fid))_ Measures the delay between the time when a user interacts with a page (e.g., clicks a button, taps on a link) and the time when the browser responds to that interaction\n\n### Size of Network resources\n\n### Network request waterfall flatness\n\nMeasures the number of requests that will be initiated once preceding requests were completed\n\n### Research\n\n- DOMContentLoaded\n- Google Crux\n- Preloading images\n- webpagetest.org\n- Next.js traces","../../docs/goals.md","0ae60737f8b21d7f",{"html":40,"metadata":41},"\u003Ch1 id=\"main-goals-that-strategies-and-technologies-should-achieve\">Main goals that strategies and technologies should achieve\u003C/h1>\n\u003Cp>The most relevant achievements that should be looked at, are the user satisfaction and the production cost.\u003C/p>\n\u003Cp>The production cost can be split into labour cost (business, legal, marketing, ux, ui, development, qa, operations and probably many more) and other costs (hardware, software, licenses and many more). The user satisfaction is tied to the performace, correctness, availability, security, usability and a bunch of psychological influences that I don’t know enough of to write about.\u003C/p>\n\u003Cp>To evaluate strategies and tools to build frontends for web applications, this deep dive will focus on the labour cost of development and the performance and usability of the product. With the exception of security, most other costs and causes for user satisfaction are not very strongly influenced by the choice of frontend application tooling.\u003C/p>\n\u003Cp>To make solutions comparable, we will take specific measurements, more subjective evaluations and turn them into ratings on a scale of 1 (very bad) to 10 (very good).\u003C/p>\n\u003Ch2 id=\"development-cost\">Development cost\u003C/h2>\n\u003Cp>The development cost is directly related to the time spent on a specific iteration of the product. So whichever solution supports the team the most in building and mainting the product, will be the most cost effective one. The time will be influenced by…\u003C/p>\n\u003Cul>\n\u003Cli>\u003Cstrong>Setup Time\u003C/strong>: Measure the time taken to set up a new project with each framework\u003C/li>\n\u003Cli>\u003Cstrong>Developer Productivity\u003C/strong>: Evaluate the ease of development, availability of documentation, and community support\u003C/li>\n\u003Cli>\u003Cstrong>Maintainability\u003C/strong>: Assess how easy it is to add new features and refactor existing code\n\u003Cul>\n\u003Cli>\u003Cstrong>Consistency\u003C/strong>: Evaluate adherence to coding standards and best practices\u003C/li>\n\u003Cli>\u003Cstrong>Testability\u003C/strong>: Measure the ease of writing unit tests and integration tests for the codebase\u003C/li>\n\u003Cli>\u003Cstrong>Complexity\u003C/strong>\n\u003Cul>\n\u003Cli>\u003Cstrong>Code Complexity\u003C/strong>: Use tools like cyclomatic complexity to measure the complexity of the codebase\u003C/li>\n\u003Cli>\u003Cstrong>Architecture Complexity\u003C/strong>: Evaluate the complexity of the chosen architecture\u003C/li>\n\u003Cli>\u003Cstrong>Dependency Management\u003C/strong>: Assess the complexity of managing dependencies and version compatibility\u003C/li>\n\u003Cli>\u003Cstrong>Tooling Complexity\u003C/strong>: Measure the complexity of tooling required for development, testing, and deployment\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ul>\n\u003Cp>We won’t look at all of these measurements in detail and might only add them to the mix once we realised that indeed there are significant differences between the solutions. The focus will be on \u003Cstrong>Developer Productivity\u003C/strong> and \u003Cstrong>Maintainability\u003C/strong> via \u003Cstrong>Complexity\u003C/strong> and \u003Cstrong>Testability\u003C/strong>.\u003C/p>\n\u003Ch2 id=\"performance\">Performance\u003C/h2>\n\u003Cp>While improving the performance can be a cost cutting operation, we’ll look at it from the perspective of user satisfaction. Which means only metrics that influence the user experience directly will be looked at.\u003C/p>\n\u003Ch3 id=\"largest-contentful-paint-lcp\">Largest Contentful Paint (LCP)\u003C/h3>\n\u003Cp>Measures the time it takes for the largest content element (e.g., image, text block) within the viewport to become visible to the user\u003C/p>\n\u003Ch3 id=\"cumulative-layout-shift-cls\">Cumulative Layout Shift (CLS)\u003C/h3>\n\u003Cp>Measures the cumulative sum of all individual layout shift scores that occur during the entire lifespan of the page\u003C/p>\n\u003Ch3 id=\"interaction-to-next-paint-inp\">Interaction to Next Paint (INP)\u003C/h3>\n\u003Cp>\u003Cem>(\u003Ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEventTiming/interactionId#browser_compatibility\">Limited Browser Support as of 08.2024\u003C/a>)\u003C/em> INP improves on FID by observing all interactions on a page, beginning from the input delay, to the time it takes to run event handlers, and finally up until the browser has painted the next frame.\u003C/p>\n\u003Ch3 id=\"first-input-delay-fid\">First Input Delay (FID)\u003C/h3>\n\u003Cp>\u003Cem>(\u003Ca href=\"https://web.dev/articles/inp#inp-vs-fid\">Succeeded by INP\u003C/a>)\u003C/em> Measures the delay between the time when a user interacts with a page (e.g., clicks a button, taps on a link) and the time when the browser responds to that interaction\u003C/p>\n\u003Ch3 id=\"size-of-network-resources\">Size of Network resources\u003C/h3>\n\u003Ch3 id=\"network-request-waterfall-flatness\">Network request waterfall flatness\u003C/h3>\n\u003Cp>Measures the number of requests that will be initiated once preceding requests were completed\u003C/p>\n\u003Ch3 id=\"research\">Research\u003C/h3>\n\u003Cul>\n\u003Cli>DOMContentLoaded\u003C/li>\n\u003Cli>Google Crux\u003C/li>\n\u003Cli>Preloading images\u003C/li>\n\u003Cli>webpagetest.org\u003C/li>\n\u003Cli>Next.js traces\u003C/li>\n\u003C/ul>",{"headings":42,"localImagePaths":74,"remoteImagePaths":75,"frontmatter":76,"imagePaths":77},[43,46,49,52,56,59,62,65,68,71],{"depth":22,"slug":44,"text":45},"main-goals-that-strategies-and-technologies-should-achieve","Main goals that strategies and technologies should achieve",{"depth":26,"slug":47,"text":48},"development-cost","Development cost",{"depth":26,"slug":50,"text":51},"performance","Performance",{"depth":53,"slug":54,"text":55},3,"largest-contentful-paint-lcp","Largest Contentful Paint (LCP)",{"depth":53,"slug":57,"text":58},"cumulative-layout-shift-cls","Cumulative Layout Shift (CLS)",{"depth":53,"slug":60,"text":61},"interaction-to-next-paint-inp","Interaction to Next Paint (INP)",{"depth":53,"slug":63,"text":64},"first-input-delay-fid","First Input Delay (FID)",{"depth":53,"slug":66,"text":67},"size-of-network-resources","Size of Network resources",{"depth":53,"slug":69,"text":70},"network-request-waterfall-flatness","Network request waterfall flatness",{"depth":53,"slug":72,"text":73},"research","Research",[],[],{},[],"strategies",{"id":78,"data":80,"body":81,"filePath":82,"digest":83,"rendered":84},{},"# Strategies and Architectures and representative Technologies\n\n## (Pure) Server-Side Rendering (SSR)\n\nServer-side rendering (SSR) is a technique in web development where the server generates the complete HTML content of a web page and sends it to the client. This allows the client to receive a fully rendered page, ready to be displayed, without the need for additional client-side rendering. The strengths of SSR include improved [Largest Contentful Paint (LCP)](./goals.md#largest-contentful-paint-lcp), better [search engine optimization (SEO)](https://en.wikipedia.org/wiki/Search_engine_optimization), and enhanced accessibility. However, SSR can be more resource-intensive on the server, may require additional server-side processing, and can limit the interactivity of the web application compared to client-side rendering.\n\n**Representatives**: [Ruby on Rails](https://rubyonrails.org/), [Spring Boot](https://spring.io/projects/spring-boot), [Laravel](https://laravel.com/), [Django](https://www.djangoproject.com/), [ASP.NET](https://www.asp.net/), [Astro](https://astro.build/)\n\n## Client-Side Rendering (CSR)\n\nClient-side rendering is a technique in web development where the rendering of a web page is done on the client's browser using JavaScript. This means that the initial HTML content is sent to the client, and then the browser executes the JavaScript code to render and display the page. The strengths of client-side rendering include enhanced interactivity, dynamic content updates, and the ability to build complex user interfaces. However, it can lead to slower [Largest Contentful Paint (LCP)](./goals.md#largest-contentful-paint-lcp), reduced [search engine optimization (SEO)](https://en.wikipedia.org/wiki/Search_engine_optimization) capabilities, and potential performance issues on lower-powered devices.\n\n**Representatives**: [React](https://react.dev/), [Vue](https://vuejs.org/), [Solid](https://www.solidjs.com/), [Svelte](https://svelte.dev/)\n\n## Hydration (SSR + CSR)\n\nHydration refers to the process of making a server-rendered website interactive in the browser. It allows the website to become dynamic and respond to user interactions. The strengths of hydration include improved user experience, faster interactivity, and the ability to handle complex user interfaces. However, hydration can also introduce challenges such as increased complexity in development, potential performance issues, and the need for careful management of data serialization and transmission.\n\n**Representatives**: [Next.js](https://nextjs.org/), [Remix](https://remix.run/), [Solid Start](https://start.solidjs.com/), [Sveltekit](https://kit.svelte.dev/), [Qwik](https://qwik.builder.io/)\n\n## Islands Architecture\n\nIslands architecture is an approach that aims to reduce the JavaScript footprint in web applications by explicitly specifying what components should be sent to the client. It allows for selective rendering of components, resulting in smaller bundle sizes and improved performance. The strengths of Islands architecture include reduced JavaScript payload, faster initial page load times, and improved scalability. However, it may introduce added complexity, especially when combined with server components, and requires careful management of state preservation and routing.\n\n**Representaives**: [Astro](https://astro.build/), [HTMX](https://htmx.org/), _Any traditional server-side rendered MPAs, that included JavaScript to fetch HTML content (Ajax) to update the DOM followed this principle years ago_\n\n## Resumability\n\nResumability is an approach that focuses on reducing the execution cost of [hydration](#hydration-ssr--csr) in web applications. Instead of trying to [minimize the amount of code that is hydrated](#islands-architecture), resumability aims to remove the overhead of hydration itself. Its strengths lie in reducing the execution cost of hydration, improving performance, and allowing for more efficient use of resources. However, resumability may introduce complexity, especially when combined with other architectural approaches, and requires careful management of state and data serialization.\n\n**Representative**: [Qwik](https://qwik.builder.io/)\n\n## React Server Components\n\n**Rendering in the context of React Server Components doesn't mean producing HTML or manipulating the DOM, but generating the [React Server Component Payload](https://www.plasmic.app/blog/how-react-server-components-work#2-server-serializes-root-component-element-to-json) that is used by React in the [Browser to render all (server & client) components](https://www.plasmic.app/blog/how-react-server-components-work#3-browser-reconstructs-the-react-tree).**\n\n[React Server Components](https://www.joshwcomeau.com/react/server-components/) are a feature in React that allow for partial rendering of components on the server. This means that only the necessary parts of a component are rendered on the server and sent to the client, reducing the amount of data that needs to be downloaded. The strengths of React Server Components include improved performance by reducing the payload size, better server-side rendering capabilities, and the ability to handle components with large dependencies. However, it may introduce added complexity to the development process and requires careful management of state and data synchronization between the server and client.\n\n## Sources\n\n- https://dev.to/this-is-learning/islands-server-components-resumability-oh-my-319d\n- https://www.epicweb.dev/the-webs-next-transition\n- https://www.joshwcomeau.com/react/server-components/\n- https://www.plasmic.app/blog/how-react-server-components-work","../../docs/strategies.md","e16974068a64b9bf",{"html":85,"metadata":86},"\u003Ch1 id=\"strategies-and-architectures-and-representative-technologies\">Strategies and Architectures and representative Technologies\u003C/h1>\n\u003Ch2 id=\"pure-server-side-rendering-ssr\">(Pure) Server-Side Rendering (SSR)\u003C/h2>\n\u003Cp>Server-side rendering (SSR) is a technique in web development where the server generates the complete HTML content of a web page and sends it to the client. This allows the client to receive a fully rendered page, ready to be displayed, without the need for additional client-side rendering. The strengths of SSR include improved \u003Ca href=\"./goals.md#largest-contentful-paint-lcp\">Largest Contentful Paint (LCP)\u003C/a>, better \u003Ca href=\"https://en.wikipedia.org/wiki/Search_engine_optimization\">search engine optimization (SEO)\u003C/a>, and enhanced accessibility. However, SSR can be more resource-intensive on the server, may require additional server-side processing, and can limit the interactivity of the web application compared to client-side rendering.\u003C/p>\n\u003Cp>\u003Cstrong>Representatives\u003C/strong>: \u003Ca href=\"https://rubyonrails.org/\">Ruby on Rails\u003C/a>, \u003Ca href=\"https://spring.io/projects/spring-boot\">Spring Boot\u003C/a>, \u003Ca href=\"https://laravel.com/\">Laravel\u003C/a>, \u003Ca href=\"https://www.djangoproject.com/\">Django\u003C/a>, \u003Ca href=\"https://www.asp.net/\">ASP.NET\u003C/a>, \u003Ca href=\"https://astro.build/\">Astro\u003C/a>\u003C/p>\n\u003Ch2 id=\"client-side-rendering-csr\">Client-Side Rendering (CSR)\u003C/h2>\n\u003Cp>Client-side rendering is a technique in web development where the rendering of a web page is done on the client’s browser using JavaScript. This means that the initial HTML content is sent to the client, and then the browser executes the JavaScript code to render and display the page. The strengths of client-side rendering include enhanced interactivity, dynamic content updates, and the ability to build complex user interfaces. However, it can lead to slower \u003Ca href=\"./goals.md#largest-contentful-paint-lcp\">Largest Contentful Paint (LCP)\u003C/a>, reduced \u003Ca href=\"https://en.wikipedia.org/wiki/Search_engine_optimization\">search engine optimization (SEO)\u003C/a> capabilities, and potential performance issues on lower-powered devices.\u003C/p>\n\u003Cp>\u003Cstrong>Representatives\u003C/strong>: \u003Ca href=\"https://react.dev/\">React\u003C/a>, \u003Ca href=\"https://vuejs.org/\">Vue\u003C/a>, \u003Ca href=\"https://www.solidjs.com/\">Solid\u003C/a>, \u003Ca href=\"https://svelte.dev/\">Svelte\u003C/a>\u003C/p>\n\u003Ch2 id=\"hydration-ssr--csr\">Hydration (SSR + CSR)\u003C/h2>\n\u003Cp>Hydration refers to the process of making a server-rendered website interactive in the browser. It allows the website to become dynamic and respond to user interactions. The strengths of hydration include improved user experience, faster interactivity, and the ability to handle complex user interfaces. However, hydration can also introduce challenges such as increased complexity in development, potential performance issues, and the need for careful management of data serialization and transmission.\u003C/p>\n\u003Cp>\u003Cstrong>Representatives\u003C/strong>: \u003Ca href=\"https://nextjs.org/\">Next.js\u003C/a>, \u003Ca href=\"https://remix.run/\">Remix\u003C/a>, \u003Ca href=\"https://start.solidjs.com/\">Solid Start\u003C/a>, \u003Ca href=\"https://kit.svelte.dev/\">Sveltekit\u003C/a>, \u003Ca href=\"https://qwik.builder.io/\">Qwik\u003C/a>\u003C/p>\n\u003Ch2 id=\"islands-architecture\">Islands Architecture\u003C/h2>\n\u003Cp>Islands architecture is an approach that aims to reduce the JavaScript footprint in web applications by explicitly specifying what components should be sent to the client. It allows for selective rendering of components, resulting in smaller bundle sizes and improved performance. The strengths of Islands architecture include reduced JavaScript payload, faster initial page load times, and improved scalability. However, it may introduce added complexity, especially when combined with server components, and requires careful management of state preservation and routing.\u003C/p>\n\u003Cp>\u003Cstrong>Representaives\u003C/strong>: \u003Ca href=\"https://astro.build/\">Astro\u003C/a>, \u003Ca href=\"https://htmx.org/\">HTMX\u003C/a>, \u003Cem>Any traditional server-side rendered MPAs, that included JavaScript to fetch HTML content (Ajax) to update the DOM followed this principle years ago\u003C/em>\u003C/p>\n\u003Ch2 id=\"resumability\">Resumability\u003C/h2>\n\u003Cp>Resumability is an approach that focuses on reducing the execution cost of \u003Ca href=\"#hydration-ssr--csr\">hydration\u003C/a> in web applications. Instead of trying to \u003Ca href=\"#islands-architecture\">minimize the amount of code that is hydrated\u003C/a>, resumability aims to remove the overhead of hydration itself. Its strengths lie in reducing the execution cost of hydration, improving performance, and allowing for more efficient use of resources. However, resumability may introduce complexity, especially when combined with other architectural approaches, and requires careful management of state and data serialization.\u003C/p>\n\u003Cp>\u003Cstrong>Representative\u003C/strong>: \u003Ca href=\"https://qwik.builder.io/\">Qwik\u003C/a>\u003C/p>\n\u003Ch2 id=\"react-server-components\">React Server Components\u003C/h2>\n\u003Cp>\u003Cstrong>Rendering in the context of React Server Components doesn’t mean producing HTML or manipulating the DOM, but generating the \u003Ca href=\"https://www.plasmic.app/blog/how-react-server-components-work#2-server-serializes-root-component-element-to-json\">React Server Component Payload\u003C/a> that is used by React in the \u003Ca href=\"https://www.plasmic.app/blog/how-react-server-components-work#3-browser-reconstructs-the-react-tree\">Browser to render all (server &#x26; client) components\u003C/a>.\u003C/strong>\u003C/p>\n\u003Cp>\u003Ca href=\"https://www.joshwcomeau.com/react/server-components/\">React Server Components\u003C/a> are a feature in React that allow for partial rendering of components on the server. This means that only the necessary parts of a component are rendered on the server and sent to the client, reducing the amount of data that needs to be downloaded. The strengths of React Server Components include improved performance by reducing the payload size, better server-side rendering capabilities, and the ability to handle components with large dependencies. However, it may introduce added complexity to the development process and requires careful management of state and data synchronization between the server and client.\u003C/p>\n\u003Ch2 id=\"sources\">Sources\u003C/h2>\n\u003Cul>\n\u003Cli>\u003Ca href=\"https://dev.to/this-is-learning/islands-server-components-resumability-oh-my-319d\">https://dev.to/this-is-learning/islands-server-components-resumability-oh-my-319d\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"https://www.epicweb.dev/the-webs-next-transition\">https://www.epicweb.dev/the-webs-next-transition\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"https://www.joshwcomeau.com/react/server-components/\">https://www.joshwcomeau.com/react/server-components/\u003C/a>\u003C/li>\n\u003Cli>\u003Ca href=\"https://www.plasmic.app/blog/how-react-server-components-work\">https://www.plasmic.app/blog/how-react-server-components-work\u003C/a>\u003C/li>\n\u003C/ul>",{"headings":87,"localImagePaths":112,"remoteImagePaths":113,"frontmatter":114,"imagePaths":115},[88,91,94,97,100,103,106,109],{"depth":22,"slug":89,"text":90},"strategies-and-architectures-and-representative-technologies","Strategies and Architectures and representative Technologies",{"depth":26,"slug":92,"text":93},"pure-server-side-rendering-ssr","(Pure) Server-Side Rendering (SSR)",{"depth":26,"slug":95,"text":96},"client-side-rendering-csr","Client-Side Rendering (CSR)",{"depth":26,"slug":98,"text":99},"hydration-ssr--csr","Hydration (SSR + CSR)",{"depth":26,"slug":101,"text":102},"islands-architecture","Islands Architecture",{"depth":26,"slug":104,"text":105},"resumability","Resumability",{"depth":26,"slug":107,"text":108},"react-server-components","React Server Components",{"depth":26,"slug":110,"text":111},"sources","Sources",[],[],{},[],"readme",{"id":116,"data":118,"body":119,"filePath":120,"digest":121,"rendered":122},{},"# Howto - Web Frontend\n\nIdentify different technical strategies and products, their strengths and weaknesses and produce a guide to help choosing a well fitting strategy and product for an aspired web frontend.\n\n## Plan\n\n- [x] Summarize the historic context of web development\n- [x] Identify main goals that strategies and technologies should achieve\n- [x] Identify main strategies and architectures and representative technologies\n- [ ] Establish measuring solutions for the goals\n- [ ] Develop a small sample application for every chosen architecture/strategy\n- [ ] Measure them against the identified goals\n- [ ] Document the results","../../docs/README.md","4a48aff9e415433d",{"html":123,"metadata":124},"\u003Ch1 id=\"howto---web-frontend\">Howto - Web Frontend\u003C/h1>\n\u003Cp>Identify different technical strategies and products, their strengths and weaknesses and produce a guide to help choosing a well fitting strategy and product for an aspired web frontend.\u003C/p>\n\u003Ch2 id=\"plan\">Plan\u003C/h2>\n\u003Cul class=\"contains-task-list\">\n\u003Cli class=\"task-list-item\">\u003Cinput type=\"checkbox\" checked disabled> Summarize the historic context of web development\u003C/li>\n\u003Cli class=\"task-list-item\">\u003Cinput type=\"checkbox\" checked disabled> Identify main goals that strategies and technologies should achieve\u003C/li>\n\u003Cli class=\"task-list-item\">\u003Cinput type=\"checkbox\" checked disabled> Identify main strategies and architectures and representative technologies\u003C/li>\n\u003Cli class=\"task-list-item\">\u003Cinput type=\"checkbox\" disabled> Establish measuring solutions for the goals\u003C/li>\n\u003Cli class=\"task-list-item\">\u003Cinput type=\"checkbox\" disabled> Develop a small sample application for every chosen architecture/strategy\u003C/li>\n\u003Cli class=\"task-list-item\">\u003Cinput type=\"checkbox\" disabled> Measure them against the identified goals\u003C/li>\n\u003Cli class=\"task-list-item\">\u003Cinput type=\"checkbox\" disabled> Document the results\u003C/li>\n\u003C/ul>",{"headings":125,"localImagePaths":132,"remoteImagePaths":133,"frontmatter":134,"imagePaths":135},[126,129],{"depth":22,"slug":127,"text":128},"howto---web-frontend","Howto - Web Frontend",{"depth":26,"slug":130,"text":131},"plan","Plan",[],[],{},[]]